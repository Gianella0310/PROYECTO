<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Geovisor Supabase - Loja</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      margin: 0; 
      padding: 0; 
      background: #f8f9fa;
    }
    .container { 
      display: flex; 
      height: 100vh; 
    }
    .sidebar { 
      width: 350px; 
      background: white; 
      border-right: 1px solid #ddd; 
      overflow-y: auto; 
      padding: 20px; 
      box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    }
    .map-container { 
      flex: 1; 
      position: relative; 
    }
    #map { 
      height: 100%; 
      width: 100%; 
    }
    h1 { 
      color: #2c3e50; 
      margin-top: 0; 
      font-size: 1.5em; 
    }
    h2 { 
      color: #34495e; 
      font-size: 1.2em; 
      margin-bottom: 15px; 
    }
    h3 { 
      color: #34495e; 
      font-size: 1.1em; 
      margin-top: 20px; 
    }
    h4 {
      color: #34495e;
      font-size: 1em;
      margin: 5px 0;
    }
    ul { 
      list-style: none; 
      padding: 0; 
    }
    li { 
      margin: 8px 0; 
      padding: 10px; 
      background: #f8f9fa; 
      border-radius: 5px; 
      border-left: 4px solid #3498db; 
    }
    li.geo-loaded {
      background: #e8f5e8;
      border-left-color: #27ae60;
    }
    a { 
      color: #3498db; 
      cursor: pointer; 
      text-decoration: none; 
      font-weight: 500; 
    }
    a:hover { 
      color: #2980b9; 
      text-decoration: underline; 
    }
    #status { 
      color: #e74c3c; 
      margin: 10px 0; 
      padding: 10px; 
      background: #fff5f5; 
      border-radius: 5px; 
      border-left: 4px solid #e74c3c; 
    }
    #status.success { 
      color: #27ae60; 
      background: #f0fff4; 
      border-left-color: #27ae60; 
    }
    #status.loading { 
      color: #f39c12; 
      background: #fffbf0; 
      border-left-color: #f39c12; 
    }
    table { 
      border-collapse: collapse; 
      width: 100%; 
      margin-top: 15px; 
      font-size: 0.9em; 
    }
    th, td { 
      border: 1px solid #ddd; 
      padding: 8px; 
      text-align: left; 
    }
    th { 
      background: #3498db; 
      color: white; 
      font-weight: bold; 
    }
    tr:nth-child(even) { 
      background: #f2f2f2; 
    }
    .geo-info { 
      background: #e8f4f8; 
      padding: 10px; 
      border-radius: 5px; 
      margin: 10px 0; 
      border-left: 4px solid #16a085; 
    }
    .layer-controls { 
      position: absolute; 
      top: 10px; 
      right: 10px; 
      background: white; 
      padding: 10px; 
      border-radius: 5px; 
      box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
      z-index: 1000;
      width: 280px;
    }
    .chart-container {
      position: absolute;
      top: 250px;
      right: 10px;
      background: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
      width: 280px;
    }
    #damageChart {
      width: 100% !important;
      height: auto !important;
      max-height: 250px;
    }
    .layer-item { 
      display: flex; 
      align-items: center; 
      margin: 5px 0; 
    }
    .layer-item input { 
      margin-right: 8px; 
    }
    .color-indicator { 
      width: 20px; 
      height: 20px; 
      border-radius: 50%; 
      margin-right: 8px; 
      border: 2px solid #fff; 
      box-shadow: 0 1px 3px rgba(0,0,0,0.3); 
    }
    .loading-indicator {
      color: #f39c12;
      font-size: 0.9em;
      margin-left: 10px;
    }
    .leaflet-control-layers {
      box-shadow: 0 1px 5px rgba(0,0,0,0.4);
      background: white;
      border-radius: 5px;
      padding: 5px 10px;
    }
    .custom-tooltip {
      background-color: rgba(255, 255, 255, 0.8);
      color: black;
      border: 1px solid #ccc;
      font-size: 12px;
      padding: 1px 4px;
      border-radius: 3px;
      transition: font-size 0.2s;
    }
    .leaflet-zoom-anim .custom-tooltip {
      font-size: 10px;
    }
    .report-form-container {
      margin-top: 20px;
      border-top: 1px solid #eee;
      padding-top: 15px;
    }
    .report-form {
      display: none;
      background: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
      margin-top: 10px;
    }
    .report-form.active {
      display: block;
    }
    .form-group {
      margin-bottom: 10px;
    }
    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: #2c3e50;
    }
    .form-group input, 
    .form-group textarea, 
    .form-group select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .form-group textarea {
      height: 80px;
      resize: vertical;
    }
    .form-actions {
      margin-top: 15px;
      text-align: right;
    }
    .btn {
      padding: 8px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
    }
    .btn-primary {
      background-color: #3498db;
      color: white;
    }
    .btn-primary:hover {
      background-color: #2980b9;
    }
    .btn-secondary {
      background-color: #95a5a6;
      color: white;
    }
    .btn-secondary:hover {
      background-color: #7f8c8d;
    }
    .form-error {
      color: #e74c3c;
      font-size: 0.8em;
      margin-top: 5px;
    }
    .form-success {
      color: #27ae60;
      background: #e8f5e9;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
      display: none;
    }
    .toggle-form-btn {
      display: block;
      width: 100%;
      text-align: center;
      margin-top: 15px;
      padding: 8px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .toggle-form-btn:hover {
      background: #2980b9;
    }
    .location-controls {
      display: flex;
      gap: 10px;
      margin-top: 5px;
    }
    .location-btn {
      padding: 5px 10px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8em;
    }
    .location-btn:hover {
      background: #2980b9;
    }
    .location-status {
      font-size: 0.8em;
      color: #7f8c8d;
      margin-top: 3px;
    }
    .location-error {
      color: #e74c3c;
    }
  </style>
</head>
<body>

<div class="container">
  <div class="sidebar">
    <h1>üó∫Ô∏è Geovisor Supabase - Loja</h1>
    <div id="status" class="loading">üîÑ Cargando tablas disponibles...</div>
    <div id="tables"></div>
    <div id="preview"></div>
    
    <!-- Secci√≥n del formulario de reportes -->
    <div class="report-form-container">
      <button id="toggleFormBtn" class="toggle-form-btn">‚ûï Nuevo Reporte de Da√±o</button>
      <div id="reportForm" class="report-form">
        <h3>Nuevo Reporte de Da√±o</h3>
        <form id="damageReportForm">
          <div class="form-group">
            <label for="tipo_dano">Tipo de da√±o *</label>
            <select id="tipo_dano" required>
              <option value="">Seleccione...</option>
              <option value="Estructural">Estructural</option>
              <option value="Hidr√°ulico">Hidr√°ulico</option>
              <option value="El√©ctrico">El√©ctrico</option>
              <option value="Vial">Vial</option>
              <option value="Otro">Otro</option>
            </select>
          </div>
          
          <div class="form-group">
            <label for="descripcion">Descripci√≥n *</label>
            <textarea id="descripcion" required></textarea>
          </div>
          
          <div class="form-group">
            <label for="gravedad">Gravedad *</label>
            <select id="gravedad" required>
              <option value="">Seleccione...</option>
              <option value="Ninguno">Ninguno</option>
              <option value="Muy leve">Muy leve</option>
              <option value="Leve">Leve</option>
              <option value="Moderado">Moderado</option>
              <option value="Severo">Severo</option>
              <option value="Muy severo">Muy severo</option>
              <option value="Colapso parcial">Colapso parcial</option>
              <option value="Colapso">Colapso</option>
            </select>
          </div>
          
          <div class="form-group">
            <label for="latitud">Latitud *</label>
            <input type="number" id="latitud" step="any" required>
            <div class="location-controls">
              <button id="getLocationBtn" class="location-btn">Obtener mi ubicaci√≥n</button>
              <button id="mapLocationBtn" class="location-btn">Seleccionar en mapa</button>
            </div>
            <div id="locationStatus" class="location-status"></div>
          </div>
          
          <div class="form-group">
            <label for="longitud">Longitud *</label>
            <input type="number" id="longitud" step="any" required>
          </div>
          
          <div class="form-group">
            <label for="fecha_reporte">Fecha del reporte</label>
            <input type="datetime-local" id="fecha_reporte">
          </div>
          
          <div class="form-group">
            <label for="reportado_por">Reportado por</label>
            <input type="text" id="reportado_por" placeholder="Opcional">
          </div>
          
          <div id="formError" class="form-error"></div>
          <div id="formSuccess" class="form-success">‚úÖ Reporte enviado correctamente</div>
          
          <div class="form-actions">
            <button type="button" class="btn btn-secondary" id="cancelBtn">Cancelar</button>
            <button type="submit" class="btn btn-primary">Enviar Reporte</button>
          </div>
        </form>
      </div>
    </div>
  </div>
  
  <div class="map-container">
    <div id="map"></div>
    <div class="layer-controls">
      <h4 style="margin-top: 0;">Capas Activas</h4>
      <div id="layer-list"></div>
    </div>
    
    <!-- Gr√°fico de pastel para tipos de da√±o -->
    <div class="chart-container">
      <h4 style="margin-top: 0;">Distribuci√≥n de Tipos de Da√±o</h4>
      <canvas id="damageChart"></canvas>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script>
  // Configuraci√≥n Supabase
  const SUPABASE_URL = 'https://ohdepbxeacibmgbfvexm.supabase.co';
  const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9oZGVwYnhlYWNpYm1nYmZ2ZXhtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI0MzMzMTYsImV4cCI6MjA2ODAwOTMxNn0.NKNSSbkevcDoFUhW0v0SqQGCVcy-Jr9r8Xyetzx6oTw';

  // Variables globales
  let map;
  let layers = {};
  let layerColors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#34495e', '#e67e22'];
  let colorIndex = 0;
  let baseLayers = {};
  let allBounds = [];
  
  // Colores para niveles de gravedad
  const gravedadColors = {
    "Ninguno": "#fceaad",      // Amarillo casi blanco
    "Muy leve": "#8ad50b",         // Verde
    "Leve": "#8ad565",             // Verde calro
    "Moderado": "#f1d565",         // Amarillo claro
    "Severo": "#f1c40f",           // Amarillo
    "Muy severo": "#e67e22",       // Naranja
    "Colapso parcial": "#f00019",  // Rojo
    "Colapso": "#f000f0"           // Morado
  };

  // Variables para el gr√°fico
  let damageChart;
  let damageTypeCounts = {
    "Estructural": 0,
    "Hidr√°ulico": 0,
    "El√©ctrico": 0,
    "Vial": 0,
    "Otro": 0
  };

  // Inicializar mapa
  function initMap() {
    console.log("Inicializando mapa...");
    map = L.map('map').setView([-3.9906, -79.2048], 14);

    // Capas base
    const streetMap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap contributors',
      name: 'Mapa Callejero'
    });

    const satellite = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
      attribution: 'Google Satellite',
      name: 'Imagen Satelital',
      maxZoom: 20
    });

    baseLayers = {
      "Imagen Satelital": satellite,
      "Mapa Callejero": streetMap
    };

    satellite.addTo(map);
    console.log("Mapa base cargado correctamente");

    map.on('zoomend', () => {
      const zoom = map.getZoom();
      const size = zoom >= 17 ? '14px' : zoom >= 15 ? '12px' : '10px';
      document.querySelectorAll('.custom-tooltip').forEach(el => {
        el.style.fontSize = size;
      });
    });

    L.control.layers(baseLayers, null, {
      position: 'bottomright'
    }).addTo(map);

    L.control.scale({position: 'bottomleft'}).addTo(map);
  }

  // Inicializar gr√°fico de tipos de da√±o
  function initDamageChart() {
    const ctx = document.getElementById('damageChart').getContext('2d');
    
    damageChart = new Chart(ctx, {
      type: 'pie',
      data: {
        labels: Object.keys(damageTypeCounts),
        datasets: [{
          data: Object.values(damageTypeCounts),
          backgroundColor: [
            '#e74c3c', // Estructural
            '#3498db', // Hidr√°ulico
            '#f39c12', // El√©ctrico
            '#2ecc71', // Vial
            '#9b59b6'  // Otro
          ],
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'bottom',
          },
          tooltip: {
            callbacks: {
              label: function(context) {
                const label = context.label || '';
                const value = context.raw || 0;
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const percentage = Math.round((value / total) * 100) || 0;
                return `${label}: ${value} (${percentage}%)`;
              }
            }
          }
        }
      }
    });
  }

  // Actualizar gr√°fico con nuevos datos
  function updateDamageChart(type) {
    if (damageTypeCounts.hasOwnProperty(type)) {
      damageTypeCounts[type]++;
      
      damageChart.data.datasets[0].data = Object.values(damageTypeCounts);
      damageChart.update();
    }
  }

  // Cargar datos iniciales del gr√°fico
  async function loadInitialDamageData() {
    try {
      const response = await fetch(`${SUPABASE_URL}/rest/v1/reportes_danos?select=tipo_dano`, {
        headers: {
          'apikey': SUPABASE_KEY,
          'Authorization': `Bearer ${SUPABASE_KEY}`
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        data.forEach(report => {
          if (damageTypeCounts.hasOwnProperty(report.tipo_dano)) {
            damageTypeCounts[report.tipo_dano]++;
          }
        });
        
        if (damageChart) {
          damageChart.data.datasets[0].data = Object.values(damageTypeCounts);
          damageChart.update();
        }
      }
    } catch (error) {
      console.error("Error cargando datos iniciales de da√±os:", error);
    }
  }

  // Cargar tablas autom√°ticamente
  window.addEventListener('DOMContentLoaded', () => {
    console.log("DOM completamente cargado");
    initMap();
    initDamageChart();
    loadInitialDamageData();
    listarTablas();
    setupForm();
  });

  // Configurar el formulario de reportes
  function setupForm() {
    console.log("Configurando formulario...");
    const toggleFormBtn = document.getElementById('toggleFormBtn');
    const reportForm = document.getElementById('reportForm');
    const cancelBtn = document.getElementById('cancelBtn');
    const damageReportForm = document.getElementById('damageReportForm');
    const formError = document.getElementById('formError');
    const formSuccess = document.getElementById('formSuccess');
    const getLocationBtn = document.getElementById('getLocationBtn');
    const mapLocationBtn = document.getElementById('mapLocationBtn');
    const locationStatus = document.getElementById('locationStatus');
    const latitudInput = document.getElementById('latitud');
    const longitudInput = document.getElementById('longitud');

    if (!toggleFormBtn || !reportForm || !cancelBtn || !damageReportForm) {
      console.error("Error: No se encontraron elementos del formulario");
      return;
    }

    // Mostrar/ocultar formulario
    toggleFormBtn.addEventListener('click', function() {
      reportForm.classList.toggle('active');
      toggleFormBtn.textContent = reportForm.classList.contains('active') ? 
        '‚úñ Cancelar' : '‚ûï Nuevo Reporte de Da√±o';
      
      // Cuando se muestra el formulario, intentar obtener ubicaci√≥n autom√°ticamente
      if (reportForm.classList.contains('active')) {
        getLocation();
      }
    });

    // Obtener ubicaci√≥n del dispositivo
    function getLocation() {
      locationStatus.textContent = "Obteniendo ubicaci√≥n...";
      locationStatus.className = "location-status";
      
      if (!navigator.geolocation) {
        locationStatus.textContent = "Geolocalizaci√≥n no soportada por tu navegador";
        locationStatus.className = "location-status location-error";
        return;
      }
      
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const lat = position.coords.latitude;
          const lng = position.coords.longitude;
          
          latitudInput.value = lat.toFixed(6);
          longitudInput.value = lng.toFixed(6);
          
          locationStatus.textContent = "Ubicaci√≥n obtenida correctamente";
          locationStatus.className = "location-status";
          
          // Centrar el mapa en la ubicaci√≥n obtenida
          map.setView([lat, lng], 16);
        },
        (error) => {
          let errorMessage;
          switch(error.code) {
            case error.PERMISSION_DENIED:
              errorMessage = "Permiso denegado por el usuario";
              break;
            case error.POSITION_UNAVAILABLE:
              errorMessage = "Informaci√≥n de ubicaci√≥n no disponible";
              break;
            case error.TIMEOUT:
              errorMessage = "Tiempo de espera agotado";
              break;
            case error.UNKNOWN_ERROR:
              errorMessage = "Error desconocido";
              break;
          }
          locationStatus.textContent = "Error al obtener ubicaci√≥n: " + errorMessage;
          locationStatus.className = "location-status location-error";
          
          // Establecer ubicaci√≥n por defecto (Loja) si no se puede obtener
          latitudInput.value = "-3.9906";
          longitudInput.value = "-79.2048";
        },
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        }
      );
    }

    // Bot√≥n para obtener ubicaci√≥n manualmente
    getLocationBtn.addEventListener('click', function(e) {
      e.preventDefault();
      getLocation();
    });

    // Bot√≥n para seleccionar en mapa
    mapLocationBtn.addEventListener('click', function(e) {
      e.preventDefault();
      locationStatus.textContent = "Haz clic en el mapa para establecer la ubicaci√≥n";
      locationStatus.className = "location-status";
      
      // Temporalmente cambiar el cursor del mapa
      map.getContainer().style.cursor = 'crosshair';
      
      // Funci√≥n temporal para capturar clic
      function onMapClick(e) {
        latitudInput.value = e.latlng.lat.toFixed(6);
        longitudInput.value = e.latlng.lng.toFixed(6);
        map.getContainer().style.cursor = '';
        map.off('click', onMapClick);
        locationStatus.textContent = "Ubicaci√≥n establecida desde el mapa";
      }
      
      map.on('click', onMapClick);
    });

    // Cancelar formulario
    cancelBtn.addEventListener('click', function() {
      reportForm.classList.remove('active');
      toggleFormBtn.textContent = '‚ûï Nuevo Reporte de Da√±o';
      damageReportForm.reset();
      formError.textContent = '';
      formSuccess.style.display = 'none';
      console.log("Formulario cancelado");
    });

    // Enviar formulario
    damageReportForm.addEventListener('submit', async function(e) {
      e.preventDefault();
      formError.textContent = '';
      formSuccess.style.display = 'none';
      console.log("Enviando formulario...");

      // Validar campos
      const tipo_dano = document.getElementById('tipo_dano').value;
      const descripcion = document.getElementById('descripcion').value;
      const gravedad = document.getElementById('gravedad').value;
      const latitud = parseFloat(document.getElementById('latitud').value);
      const longitud = parseFloat(document.getElementById('longitud').value);
      const fecha_reporte = document.getElementById('fecha_reporte').value;
      const reportado_por = document.getElementById('reportado_por').value;

      if (!tipo_dano || !descripcion || !gravedad || isNaN(latitud) || isNaN(longitud)) {
        formError.textContent = 'Por favor complete todos los campos obligatorios (*)';
        console.error("Validaci√≥n fallida: Campos obligatorios faltantes");
        return;
      }

      // Crear geometr√≠a a partir de lat/long
      const geom = {
        type: 'Point',
        coordinates: [longitud, latitud]
      };

      // Crear objeto con los datos del reporte
      const reportData = {
        tipo_dano,
        descripcion,
        gravedad,
        latitud,
        longitud,
        geom: JSON.stringify(geom),
        reportado_por: reportado_por || null,
        fecha_reporte: fecha_reporte ? new Date(fecha_reporte).toISOString() : new Date().toISOString()
      };

      console.log("Datos a enviar:", reportData);

      try {
        // Enviar datos a Supabase
        const response = await fetch(`${SUPABASE_URL}/rest/v1/reportes_danos`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'apikey': SUPABASE_KEY,
            'Authorization': `Bearer ${SUPABASE_KEY}`,
            'Prefer': 'return=representation'
          },
          body: JSON.stringify(reportData)
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Error ${response.status}: ${errorText}`);
        }

        const data = await response.json();
        console.log("Respuesta de Supabase:", data);
        
        // Actualizar gr√°fico
        updateDamageChart(tipo_dano);
        
        // Mostrar mensaje de √©xito
        formSuccess.style.display = 'block';
        damageReportForm.reset();
        
        // Recargar la capa de reportes si est√° cargada
        if (layers['reportes_danos']) {
          console.log("Recargando capa reportes_danos...");
          await loadGeoLayer('reportes_danos');
        }
        
        // Ocultar el formulario despu√©s de 2 segundos
        setTimeout(() => {
          reportForm.classList.remove('active');
          toggleFormBtn.textContent = '‚ûï Nuevo Reporte de Da√±o';
          formSuccess.style.display = 'none';
        }, 2000);
        
      } catch (error) {
        console.error("Error al enviar reporte:", error);
        formError.textContent = 'Error al enviar el reporte: ' + error.message;
      }
    });

    console.log("Formulario configurado correctamente");
  }

  async function listarTablas() {
    console.log("Listando tablas...");
    const status = document.getElementById('status');
    const tablesDiv = document.getElementById('tables');
    const preview = document.getElementById('preview');
    
    if (!status || !tablesDiv || !preview) {
      console.error("Error: Elementos del DOM no encontrados");
      return;
    }
    
    tablesDiv.innerHTML = preview.innerHTML = '';
    status.textContent = 'üîé Introspeccionando esquema via GraphQL‚Ä¶';
    status.className = 'loading';

    // Introspecci√≥n GraphQL
    const gql = `{
      __schema {
        queryType { fields { name } }
      }
    }`;

    let fields;
    try {
      console.log("Realizando consulta GraphQL...");
      const res = await fetch(`${SUPABASE_URL}/graphql/v1`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'apikey': SUPABASE_KEY,
          'Authorization': `Bearer ${SUPABASE_KEY}`
        },
        body: JSON.stringify({ query: gql })
      });
      
      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(`${res.statusText}: ${errorText}`);
      }
      
      const { data, errors } = await res.json();
      
      if (errors) {
        throw new Error(errors.map(e => e.message).join(', '));
      }
      
      fields = data.__schema.queryType.fields.map(f => f.name);
      console.log("Campos obtenidos:", fields);
    } catch (err) {
      console.error("Error en GraphQL:", err);
      status.textContent = '‚ùå GraphQL error: ' + err.message;
      status.className = '';
      return;
    }

    // Filtrar tablas Collection
    const candidates = fields
      .filter(n => n.endsWith('Collection'))
      .map(n => n.slice(0, -'Collection'.length));

    if (candidates.length === 0) {
      console.warn("No se encontraron tablas Collection");
      status.textContent = 'üö´ No hay tablas "Collection" detectadas.';
      status.className = '';
      return;
    }

    status.textContent = `‚è≥ Validando ${candidates.length} candidato(s)‚Ä¶`;
    console.log(`Validando ${candidates.length} tablas candidatas...`);

    // Validar acceso y detectar campos geoespaciales
    const validTables = [];
    await Promise.all(candidates.map(async tbl => {
      try {
        console.log(`Validando tabla ${tbl}...`);
        const r = await fetch(`${SUPABASE_URL}/rest/v1/${tbl}?select=*&limit=1`, {
          headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}` }
        });
        
        if (r.ok) {
          const data = await r.json();
          const hasGeoData = data.length > 0 && hasGeospatialFields(data[0]);
          console.log(`Tabla ${tbl} - tiene geo: ${hasGeoData}`);
          validTables.push({ name: tbl, hasGeo: hasGeoData, sample: data[0] });
        } else {
          console.warn(`Tabla ${tbl} no accesible: ${r.status}`);
        }
      } catch (err) {
        console.error(`Error validando tabla ${tbl}:`, err);
      }
    }));

    if (validTables.length === 0) {
      console.error("No hay tablas accesibles");
      status.textContent = '‚ùå Ninguna tabla es accesible con esta anon key.';
      status.className = '';
      return;
    }

    // Separar tablas geoespaciales y no geoespaciales
    const geoTables = validTables.filter(t => t.hasGeo);
    const nonGeoTables = validTables.filter(t => !t.hasGeo);

    console.log(`Tablas v√°lidas: ${validTables.length} (Geo: ${geoTables.length}, No geo: ${nonGeoTables.length})`);
    status.textContent = `‚úÖ ${validTables.length} tabla(s) accesible(s) - Cargando capas geoespaciales...`;
    status.className = 'success';

    // Mostrar todas las tablas
    const ul = document.createElement('ul');
    validTables.forEach(({ name, hasGeo, sample }) => {
      const li = document.createElement('li');
      const a = document.createElement('a');
      a.textContent = `${name} ${hasGeo ? 'üó∫Ô∏è' : 'üìÑ'}`;
      a.onclick = () => previewTabla(name, hasGeo, sample);
      
      if (hasGeo) {
        const loadingSpan = document.createElement('span');
        loadingSpan.className = 'loading-indicator';
        loadingSpan.textContent = ' ‚è≥ Cargando...';
        loadingSpan.id = `loading-${name}`;
        li.appendChild(a);
        li.appendChild(loadingSpan);
      } else {
        li.appendChild(a);
      }
      
      ul.appendChild(li);
    });
    
    tablesDiv.innerHTML = '<h2>Tablas disponibles:</h2>';
    tablesDiv.appendChild(ul);

    // Cargar autom√°ticamente todas las capas geoespaciales
    if (geoTables.length > 0) {
      console.log(`Cargando ${geoTables.length} capas geoespaciales...`);
      await loadAllGeoLayers(geoTables);
    } else {
      console.log("No hay capas geoespaciales para cargar");
    }
  }

  async function loadAllGeoLayers(geoTables) {
    console.log("Cargando todas las capas geoespaciales...");
    const status = document.getElementById('status');
    let loadedCount = 0;
    
    const loadPromises = geoTables.map(async ({ name }) => {
      try {
        console.log(`Cargando capa ${name}...`);
        await loadGeoLayer(name, true);
        loadedCount++;
        
        const loadingIndicator = document.getElementById(`loading-${name}`);
        if (loadingIndicator) {
          loadingIndicator.textContent = ' ‚úÖ Cargada';
          loadingIndicator.style.color = '#27ae60';
        }
        
        const li = loadingIndicator?.parentElement;
        if (li) {
          li.classList.add('geo-loaded');
        }
        
      } catch (error) {
        console.error(`Error cargando ${name}:`, error);
        const loadingIndicator = document.getElementById(`loading-${name}`);
        if (loadingIndicator) {
          loadingIndicator.textContent = ' ‚ùå Error';
          loadingIndicator.style.color = '#e74c3c';
        }
      }
    });

    await Promise.all(loadPromises);
    console.log(`Carga completada: ${loadedCount} capas cargadas`);

    if (allBounds.length > 0) {
      console.log("Ajustando vista del mapa a todas las capas...");
      const latlngBounds = L.latLngBounds(allBounds);
      if (latlngBounds.isValid()) {
        map.fitBounds(latlngBounds, { padding: [20, 20] });
      }
    }

    status.textContent = `‚úÖ ${loadedCount} capa(s) geoespacial(es) cargada(s) autom√°ticamente`;
    status.className = 'success';
  }

  function hasGeospatialFields(row) {
    if (!row) return false;
    
    const keys = Object.keys(row);
    const hasGeo = keys.some(key => 
      key.toLowerCase().includes('geom') || 
      key.toLowerCase().includes('geometry') ||
      key.toLowerCase().includes('location') ||
      (keys.includes('latitude') && keys.includes('longitude')) ||
      (keys.includes('lat') && keys.includes('lon')) ||
      (keys.includes('lat') && keys.includes('lng'))
    );
    
    console.log("Revisando campos geoespaciales:", keys, "Resultado:", hasGeo);
    return hasGeo;
  }

  async function previewTabla(tabla, hasGeo, sample) {
    console.log(`Previsualizando tabla ${tabla}...`);
    const status = document.getElementById('status');
    const preview = document.getElementById('preview');
    preview.innerHTML = '';
    status.textContent = `‚è≥ Cargando datos de "${tabla}"‚Ä¶`;
    status.className = 'loading';

    try {
      console.log(`Obteniendo datos de ${tabla}...`);
      const r = await fetch(`${SUPABASE_URL}/rest/v1/${tabla}?select=*&limit=100`, {
        headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}` }
      });
      
      if (!r.ok) {
        const errorText = await r.text();
        throw new Error(`${r.statusText}: ${errorText}`);
      }
      
      const data = await r.json();
      console.log(`Datos obtenidos para ${tabla}:`, data.length, "registros");

      let html = `<h3>Datos de <strong>${tabla}</strong></h3>`;
      
      if (hasGeo) {
        html += '<div class="geo-info">üó∫Ô∏è <strong>Tabla geoespacial</strong><br>';
        if (layers[tabla]) {
          html += '‚úÖ <strong>Ya cargada en el mapa</strong><br>';
          html += '<a onclick="toggleLayer(\'' + tabla + '\')">üëÅÔ∏è Mostrar/Ocultar capa</a>';
        } else {
          html += '<a onclick="loadGeoLayer(\'' + tabla + '\')">üìç Cargar en mapa</a>';
        }
        html += '</div>';
      }

      if (!data.length) {
        html += '<p>‚Äî tabla vac√≠a ‚Äî</p>';
      } else {
        html += '<table><tr>';
        Object.keys(data[0]).forEach(c => html += `<th>${c}</th>`);
        html += '</tr>';
        data.slice(0, 10).forEach(row => {
          html += '<tr>';
          Object.values(row).forEach(v => {
            const cellValue = v === null ? '<em>null</em>' : String(v);
            html += `<td>${cellValue.length > 50 ? cellValue.substring(0, 50) + '...' : cellValue}</td>`;
          });
          html += '</tr>';
        });
        html += '</table>';
        if (data.length > 10) {
          html += '<p><em>... y ' + (data.length - 10) + ' registros m√°s</em></p>';
        }
      }
      
      preview.innerHTML = html;
      status.textContent = `‚úÖ Datos de "${tabla}" cargados`;
      status.className = 'success';
    } catch (err) {
      console.error(`Error al previsualizar ${tabla}:`, err);
      status.textContent = '‚ùå Error: ' + err.message;
      status.className = '';
    }
  }

  function getLayerStyle(layerName, geometryType, color, featureProperties = {}) {
    // Estilo especial para reportes_danos
    if (layerName === 'reportes_danos' && geometryType === 'Point') {
      const gravedad = featureProperties.gravedad || 'Ningun da√±o';
      const pointColor = gravedadColors[gravedad] || color;
      
      return {
        pointStyle: {
          radius: 8,
          fillColor: pointColor,
          color: '#ffffff',
          weight: 1,
          opacity: 1,
          fillOpacity: 0.8
        }
      };
    }

    // Resto de estilos permanece igual
    const isMovimientosLadera = layerName === 'movimientos_de_ladera_a';
    
    if (geometryType === 'Point' || geometryType === 'MultiPoint') {
      return {
        pointStyle: {
          radius: 6,
          fillColor: color,
          color: color,
          weight: 1,
          opacity: 1,
          fillOpacity: 0.7
        }
      };
    }
    
    if (isMovimientosLadera) {
      return {
        polygonStyle: {
          color: color,
          weight: 2,
          opacity: 1,
          fillOpacity: 0.5,
          fillColor: color
        }
      };
    } else {
      return {
        polygonStyle: {
          color: color,
          weight: 2,
          opacity: 1,
          fillOpacity: 0,
          fillColor: 'transparent'
        }
      };
    }
  }

  async function loadGeoLayer(tabla, isAutoLoad = false) {
    console.log(`Cargando capa geoespacial ${tabla}...`);
    const status = document.getElementById('status');
    
    if (!isAutoLoad) {
      status.textContent = `‚è≥ Cargando capa geoespacial "${tabla}"‚Ä¶`;
      status.className = 'loading';
    }

    try {
      console.log(`Obteniendo datos de ${tabla}...`);
      const r = await fetch(`${SUPABASE_URL}/rest/v1/${tabla}?select=*&limit=1000`, {
        headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}` }
      });
      
      if (!r.ok) {
        const errorText = await r.text();
        throw new Error(`${r.statusText}: ${errorText}`);
      }
      
      const data = await r.json();
      console.log(`Datos obtenidos para ${tabla}:`, data.length, "registros");

      if (!data.length) {
        console.warn(`No hay datos en ${tabla}`);
        if (!isAutoLoad) {
          status.textContent = '‚ö†Ô∏è No hay datos para mostrar en el mapa';
          status.className = '';
        }
        return;
      }

      if (layers[tabla]) {
        console.log(`Removiendo capa existente ${tabla}`);
        map.removeLayer(layers[tabla]);
      }

      const color = layerColors[colorIndex % layerColors.length];
      colorIndex++;
      console.log(`Color asignado a ${tabla}:`, color);

      const layerGroup = L.layerGroup();
      let featureCount = 0;
      let bounds = [];

      data.forEach(row => {
        try {
          const geoFields = Object.entries(row).filter(([key, value]) => 
            key.toLowerCase().includes('geom') || 
            key.toLowerCase().includes('geometry') ||
            key.toLowerCase().includes('location') ||
            (typeof value === 'object' && value !== null && 
             (value.type === 'Feature' || value.coordinates || value.geometry))
          );

          console.log(`Procesando registro en ${tabla}:`, geoFields.length, "campos geoespaciales");

          for (const [fieldName, geoData] of geoFields) {
            let geometry = geoData;
            
            if (typeof geoData === 'string') {
              try {
                geometry = JSON.parse(geoData);
              } catch (e) {
                console.warn(`Error parsing ${fieldName} as JSON:`, e);
                continue;
              }
            }

            if (geometry.type === 'Feature' && geometry.geometry) {
              const geometryType = geometry.geometry.type;
              const layerStyle = getLayerStyle(tabla, geometryType, color, row);
              
              const layer = L.geoJSON(geometry, {
                pointToLayer: (feature, latlng) => {
                  return L.circleMarker(latlng, layerStyle.pointStyle || {
                    radius: 6,
                    fillColor: color,
                    color: color,
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.7
                  });
                },
                style: layerStyle.polygonStyle || {
                  color: color,
                  weight: 2,
                  opacity: 1,
                  fillOpacity: 0.5
                }
              });
              layerGroup.addLayer(layer);
              bounds = bounds.concat(getBoundsFromGeoJSON(geometry));
              featureCount++;
            } 
            else if (geometry.type && geometry.coordinates) {
              const feature = {
                type: 'Feature',
                geometry: geometry
              };
              const geometryType = geometry.type;
              const layerStyle = getLayerStyle(tabla, geometryType, color, row);
              
              const layer = L.geoJSON(feature, {
                pointToLayer: (feature, latlng) => {
                  return L.circleMarker(latlng, layerStyle.pointStyle || {
                    radius: 6,
                    fillColor: color,
                    color: color,
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.7
                  });
                },
                style: layerStyle.polygonStyle || {
                  color: color,
                  weight: 2,
                  opacity: 1,
                  fillOpacity: 0.5
                }
              });
              layerGroup.addLayer(layer);
              bounds = bounds.concat(getBoundsFromGeoJSON(feature));
              featureCount++;
            }
            else if (Array.isArray(geometry) && geometry.length >= 2 && 
                    typeof geometry[0] === 'number' && typeof geometry[1] === 'number') {
              const marker = L.circleMarker([geometry[1], geometry[0]], {
                color: color,
                fillColor: color,
                fillOpacity: 0.6,
                radius: 6
              });
              layerGroup.addLayer(marker);
              bounds.push([geometry[1], geometry[0]]);
              featureCount++;
            }
          }

          if (layerGroup.getLayers().length > 0) {
            const lastLayer = layerGroup.getLayers()[layerGroup.getLayers().length - 1];
            let popupContent = `<strong>${tabla}</strong><br>`;
            Object.entries(row).forEach(([key, value]) => {
              if (!key.toLowerCase().includes('geom') && 
                  !key.toLowerCase().includes('geometry') &&
                  !key.toLowerCase().includes('location')) {
                popupContent += `<strong>${key}:</strong> ${value}<br>`;
              }
            });
            lastLayer.bindPopup(popupContent);
          }
        } catch (e) {
          console.warn(`Error procesando registro en ${tabla}:`, e);
        }
      });

      if (featureCount > 0) {
        console.log(`Capa ${tabla} creada con ${featureCount} features`);
        layers[tabla] = layerGroup;
        layerGroup.addTo(map);
        
        allBounds = allBounds.concat(bounds);
        
        if (!isAutoLoad && bounds.length > 0) {
          const latlngBounds = L.latLngBounds(bounds);
          if (latlngBounds.isValid()) {
            console.log("Ajustando vista del mapa a la capa");
            map.fitBounds(latlngBounds, { padding: [20, 20] });
          }
        }

        updateLayerControls();

        if (!isAutoLoad) {
          status.textContent = `‚úÖ Capa "${tabla}" cargada: ${featureCount} elemento(s) geoespacial(es)`;
          status.className = 'success';
        }
      } else {
        console.warn(`No se encontraron features v√°lidas en ${tabla}`);
        if (!isAutoLoad) {
          status.textContent = `‚ö†Ô∏è No se encontraron geometr√≠as v√°lidas en "${tabla}"`;
          status.className = '';
        }
      }
    } catch (err) {
      console.error(`Error al cargar capa ${tabla}:`, err);
      if (!isAutoLoad) {
        status.textContent = '‚ùå Error cargando capa: ' + err.message;
        status.className = '';
      }
      throw err;
    }
  }

  function getBoundsFromGeoJSON(geojson) {
    const bounds = [];
    if (!geojson || !geojson.geometry) return bounds;
    
    const processCoordinates = (coords) => {
      if (Array.isArray(coords[0]) && typeof coords[0][0] === 'number') {
        coords.forEach(coord => {
          if (Array.isArray(coord[0])) {
            processCoordinates(coord);
          } else {
            bounds.push([coord[1], coord[0]]);
          }
        });
      }
    };

    switch (geojson.geometry.type) {
      case 'Point':
        bounds.push([geojson.geometry.coordinates[1], geojson.geometry.coordinates[0]]);
        break;
      case 'MultiPoint':
      case 'LineString':
        processCoordinates(geojson.geometry.coordinates);
        break;
      case 'Polygon':
      case 'MultiLineString':
        geojson.geometry.coordinates.forEach(ring => processCoordinates(ring));
        break;
      case 'MultiPolygon':
        geojson.geometry.coordinates.forEach(polygon => {
          polygon.forEach(ring => processCoordinates(ring));
        });
        break;
    }

    return bounds;
  }

  function updateLayerControls() {
    console.log("Actualizando controles de capas...");
    const layerList = document.getElementById('layer-list');
    if (!layerList) {
      console.error("Error: layer-list no encontrado");
      return;
    }
    
    layerList.innerHTML = '';

    Object.keys(layers).forEach((layerName, index) => {
      const div = document.createElement('div');
      div.className = 'layer-item';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = true;
      checkbox.onchange = () => toggleLayer(layerName);
      
      const colorIndicator = document.createElement('div');
      colorIndicator.className = 'color-indicator';
      colorIndicator.style.backgroundColor = layerColors[index % layerColors.length];
      
      const label = document.createElement('span');
      label.textContent = layerName;
      
      div.appendChild(checkbox);
      div.appendChild(colorIndicator);
      div.appendChild(label);
      layerList.appendChild(div);
    });
  }

  function toggleLayer(layerName) {
    console.log(`Alternando visibilidad de ${layerName}`);
    const layer = layers[layerName];
    if (layer) {
      if (map.hasLayer(layer)) {
        map.removeLayer(layer);
      } else {
        map.addLayer(layer);
      }
    }
  }
</script>

</body>
</html>
